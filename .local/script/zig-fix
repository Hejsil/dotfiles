#!/bin/sh -e

self=$0

# The two first ifs ensures that we only ever get 1 file as input, which
# will make the logic afterwards simpler.
if [ "$#" = 0 ]; then
    tmp=$(mktemp)
    trap 'rm "$tmp"' EXIT
    cat - >"$tmp"

    "$self" "$tmp"
    cat "$tmp"
    exit 0
fi

if [ "$#" -ne 1 ] || [ -d "$1" ]; then
    find "$@" -type f -exec "$self" {} ';'
    exit 0
fi

# while true; do
#     error=$(zig fmt "$1" --color off 2>&1 |
#         rg -o "([^:]+):(\d+):(\d+): error: expected '([^']+)', found '([^']+)'" -r "$(printf '$1\t$2\t$3\t$4\t$5')" |
#         head -n 1)

#     [ -z "$error" ] && break
#     echo "$error" | {
#         read -r file line column expected found
#         sed -i "${line}s/.\{$((column - 1))\}/&${expected}/" "$1"
#     }
# done

zig fmt "$1" >/dev/null

# Global constant groups
{
    grep -E -n '^(pub\s+)?const.*;$' "$1" | cut -d: -f1 | ranges | sed 's/$/!sort/'
    echo 'x'
} | ex -s "$1"
